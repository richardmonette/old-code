package {	import cmodule.trianglepusher.CLibInit;		import net.hires.debug.Stats;		import ObjModelFile;	import ColladaModelFile;		import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Shader;	import flash.display.ShaderJob;	import flash.display.Sprite;	import flash.display.StageAlign;	import flash.display.StageScaleMode;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.geom.Matrix3D;	import flash.geom.PerspectiveProjection;	import flash.geom.Rectangle;	import flash.geom.Vector3D;	import flash.text.TextField;	import flash.text.TextFieldAutoSize;	import flash.text.TextFormat;	import flash.ui.Keyboard;	import flash.utils.ByteArray;	import flash.utils.Endian;		    [SWF(backgroundColor="#000000", frameRate="60", width="640", height="480")]	public class TriangleMain extends Sprite 	{				private static const IMAGE_WIDTH:int = 640;		private static const IMAGE_HEIGHT:int = 480;				[Embed (source="rect.png")]		private var TextureClass : Class;		private var texture : Bitmap = new TextureClass();				[Embed (source="sampledNormals.jpg")]		private var NormalMapClass : Class;		private var normalMap : Bitmap = new NormalMapClass();				private var cLibInit : CLibInit;		private var alcPPLib : Object;		private var alcBitmapPointer : uint;		private var alcDepthBufferPointer : uint;		private var alcVertexPointer : uint;		private var alcIndexPointer  : uint;		private var alchemyMemory : ByteArray;		private var bitmapData:BitmapData;		private var bitmap : Bitmap;		private var stats : Stats;		private var clearBA : ByteArray;		private var clearDepthBA : ByteArray;		//private var model : ObjModelFile;		private var model : ColladaModelFile;		private var textField : TextField;				private var oldMouseX : int = 0;		private var oldMouseY : int = 0;		public function TriangleMain()		{			init();		}				protected function init() : void		{			stage.frameRate = 60;			stage.align = StageAlign.TOP_LEFT;			stage.scaleMode = StageScaleMode.NO_SCALE;			stage.fullScreenSourceRect = new Rectangle(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);							//model = new ObjModelFile();			model = new ColladaModelFile();			model.addEventListener(Event.COMPLETE, initAlchemy);							textField = new TextField();			textField.textColor = 0xFFFFFF;			textField.x = 450;			textField.width = 500;			textField.height = 1000;			textField.alpha = 0.75;							//initAlchemy();			initBuffers();						stats = new Stats();			stats.visible = true;			addChild(stats);						//addChild(textField);						stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);			stage.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);			stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);			stage.addEventListener(KeyboardEvent.KEY_DOWN, keyDownHandler);			stage.addEventListener(KeyboardEvent.KEY_UP, keyUpHandler);			//addEventListener(Event.ENTER_FRAME, enterFrameHandler);		}		protected function initAlchemy(e : Event) : void		{			cLibInit = new CLibInit();			alcPPLib = cLibInit.init();						var ns : Namespace = new Namespace("cmodule.trianglepusher");			alchemyMemory = (ns::gstate).ds;						alcBitmapPointer = alcPPLib.getTBufferPointer();			alcDepthBufferPointer = alcPPLib.getDepthBuffer();						// Send vertices to rasterizer						alcPPLib.initializeVertexBuffers(model.verticesLength);						alcVertexPointer = alcPPLib.getVertexBuffer();			alchemyMemory.position = alcVertexPointer;			alchemyMemory.writeBytes(model.verticesByteArray, 0, model.verticesByteArray.length);						// Send indices (vertex) to rasterizer						alcPPLib.initializeIndexBuffers(model.facesLength);						alcIndexPointer = alcPPLib.getIndexBuffer();			alchemyMemory.position = alcIndexPointer;			alchemyMemory.writeBytes(model.indicesByteArray, 0, model.indicesByteArray.length);						// Send UVS to rasterizer						alcPPLib.initializeUVBuffers(model.uvsLength);						alcIndexPointer = alcPPLib.getUVBuffer();			alchemyMemory.position = alcIndexPointer;			alchemyMemory.writeBytes(model.uvsByteArray, 0, model.uvsByteArray.length);						// Send indices (UV) to rasterizer						alcPPLib.initializeUVIndexBuffers( model.facesLength );						alcIndexPointer = alcPPLib.getUVIndexBuffer();			alchemyMemory.position = alcIndexPointer;			alchemyMemory.writeBytes(model.uvIndicesByteArray, 0, model.uvIndicesByteArray.length);						// Send Normals to rasterizer						alcPPLib.initializeNormalBuffers(model.normalsLength);						alcIndexPointer = alcPPLib.getNormalBuffer();			alchemyMemory.position = alcIndexPointer;			alchemyMemory.writeBytes(model.normalByteArray, 0, model.normalByteArray.length);						// Send indices (normals) to rasterizer						alcPPLib.initializeNormalIndexBuffers(model.facesLength);						alcIndexPointer = alcPPLib.getNormalIndexBuffer();			alchemyMemory.position = alcIndexPointer;			alchemyMemory.writeBytes(model.normalIndicesByteArray, 0, model.normalIndicesByteArray.length);						// Send Tangents to rasterizer						alcPPLib.initializeTangentBuffers(model.tangentsLength);						alcIndexPointer = alcPPLib.getTangentBuffer();			alchemyMemory.position = alcIndexPointer;			alchemyMemory.writeBytes(model.tangentByteArray, 0, model.tangentByteArray.length);						// Send indices (tangents) to rasterizer						alcPPLib.initializeTangentIndexBuffers(model.facesLength);						alcIndexPointer = alcPPLib.getTangentIndexBuffer();			alchemyMemory.position = alcIndexPointer;			alchemyMemory.writeBytes(model.tangentIndicesByteArray, 0, model.tangentIndicesByteArray.length);						// Send Binormals to rasterizer						alcPPLib.initializeBinormalBuffers(model.binormalsLength);						alcIndexPointer = alcPPLib.getBinormalBuffer();			alchemyMemory.position = alcIndexPointer;			alchemyMemory.writeBytes(model.binormalByteArray, 0, model.binormalByteArray.length);						// Send indices (binormals) to rasterizer						alcPPLib.initializeBinormalIndexBuffers(model.facesLength);						alcIndexPointer = alcPPLib.getBinormalIndexBuffer();			alchemyMemory.position = alcIndexPointer;			alchemyMemory.writeBytes(model.binormalIndicesByteArray, 0, model.binormalIndicesByteArray.length);						// Send texture to rasterizer (slow ass copy)						var bitmapByteArray : ByteArray = new ByteArray();			bitmapByteArray.endian = Endian.LITTLE_ENDIAN;						for (var x : int = 0; x < 512; x++)			{				for (var y : int = 0; y < 512; y++)				{					bitmapByteArray.writeInt(texture.bitmapData.getPixel(x, y));				}			}						alcIndexPointer = alcPPLib.getTextureBuffer();			alchemyMemory.position = alcIndexPointer;			alchemyMemory.writeBytes(bitmapByteArray, 0, bitmapByteArray.length);						// Send normalMap to rasterizer (slow ass copy)						var normalMapByteArray : ByteArray = new ByteArray();			normalMapByteArray.endian = Endian.LITTLE_ENDIAN;						for (x = 0; x < 512; x++)			{				for (y = 0; y < 512; y++)				{					normalMapByteArray.writeInt(normalMap.bitmapData.getPixel(x, y));				}			}						alcIndexPointer = alcPPLib.getNormalMapBuffer();			alchemyMemory.position = alcIndexPointer;			alchemyMemory.writeBytes(normalMapByteArray, 0, normalMapByteArray.length);						alcPPLib.buildModel();						addEventListener(Event.ENTER_FRAME, enterFrameHandler);						textField.appendText(model.log);		}				protected function initBuffers() : void		{			bitmapData = new BitmapData(IMAGE_WIDTH, IMAGE_HEIGHT, false, 0);			var clearBitmapData : BitmapData = new BitmapData(IMAGE_WIDTH, IMAGE_HEIGHT, true, 0x111111FF);						clearBA = clearBitmapData.getPixels(clearBitmapData.rect);			clearBitmapData.dispose();						var clearDepthBitmapdata : BitmapData = new BitmapData(IMAGE_WIDTH, IMAGE_HEIGHT, true, 0x000000FF);			clearDepthBA = clearDepthBitmapdata.getPixels(clearDepthBitmapdata.rect);			clearDepthBitmapdata.dispose();						bitmap = new Bitmap(bitmapData);			addChild(bitmap);		}				private function mouseDownHandler(e : MouseEvent) : void		{			alcPPLib.mouseDownHandler();		}				private function mouseUpHandler(e : MouseEvent) : void		{			alcPPLib.mouseUpHandler();		}				private function mouseMoveHandler(e : MouseEvent) : void		{			alcPPLib.mouseMoveHandler(oldMouseX - e.stageX, oldMouseY - e.stageY);						oldMouseX = e.stageX;			oldMouseY = e.stageY;		}				private function keyDownHandler(e : KeyboardEvent) : void		{			alcPPLib.keyHandler(e.keyCode, 1);		}				private function keyUpHandler(e : KeyboardEvent) : void		{			alcPPLib.keyHandler(e.keyCode, 0);		}				private function enterFrameHandler(event : Event) : void		{			alchemyMemory.position = alcBitmapPointer;			alchemyMemory.writeBytes(clearBA, 0, clearBA.length);						alchemyMemory.position = alcDepthBufferPointer;			alchemyMemory.writeBytes(clearDepthBA, 0, clearDepthBA.length);						alcPPLib.rasterize();						alchemyMemory.position = alcBitmapPointer;			bitmapData.setPixels(bitmapData.rect, alchemyMemory);					}	}}